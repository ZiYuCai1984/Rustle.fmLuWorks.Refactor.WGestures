using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable

// ReSharper disable ParameterHidesMember
// ReSharper disable NonReadonlyMemberInGetHashCode


namespace NativeMultiFileArchiveLib
{
    /// <summary>
    ///     Represents a single node within a tree.
    ///     when added to a Tree, the node becomes searchable from within the tree, and new nodes
    ///     added/updated in the
    ///     tree will be reflected in the node.
    ///     Changing the parent node value will update the children of the new parent.
    ///     The TreeNode does not need to be added to a tree to form a hierarchy. New nodes can be created
    ///     and set as the
    ///     parent of any existing node.
    ///     The hierarchy enumerations on the node will navigate through the hierarchy generated by the
    ///     linked nodes
    ///     and their children, - these methods do not require the TreeNode to be in a Tree.
    /// </summary>
    /// <typeparam name="TV">
    /// </typeparam>
    [Serializable]
    public class TreeNode<TV>
    {
        #region Constructor

        /// <summary>
        ///     default parameter less constructor.
        /// </summary>
        public TreeNode()
        {
            _nodeAddedHandler = this._owner_NodeAdded;
        }

        #endregion

        #region Handlers

        /// <summary>
        ///     Handle the "NodeAdded" event from the owning Tree object;
        ///     if the added node is a parent to this node, add the new node to this node's children
        ///     collection.
        /// </summary>
        /// <param name="sender">this will be the Tree control</param>
        /// <param name="node">
        ///     the newly added node.
        /// </param>
        private void _owner_NodeAdded(object sender, TreeNode<TV> node)
        {
            if (node.Parent == this)
            {
                if (!_children.Contains(node))
                {
                    _children.Add(node);
                }
            }
        }

        #endregion

        /// <summary>
        ///     a node is unique from it's index....
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            // generate the hash from the parent and value and index
            if (parent != null)
            {
                return (parent.Value + this.Value.ToString()).GetHashCode() + this.Index;
            }

            // ReSharper disable once PossibleNullReferenceException
            return this.Value.ToString().GetHashCode() + this.Index;
        }

        #region Fields

        /// <summary>
        ///     the owning Tree
        /// </summary>
        protected Tree<TV> owner;

        /// <summary>
        ///     the owning parent.
        /// </summary>
        protected TreeNode<TV> parent;

        /// <summary>
        ///     local cache of child objects:
        /// </summary>
        private List<TreeNode<TV>> _children = new List<TreeNode<TV>>();

        /// <summary>
        ///     handler for the parent object node added event.
        /// </summary>
        private Tree<TV>.NodeEvent _nodeAddedHandler;

        #endregion

        #region Properties

        /// <summary>
        ///     owner property.
        /// </summary>
        public Tree<TV> Owner => owner;

        /// <summary>
        ///     parent property.
        /// </summary>
        public TreeNode<TV> Parent
        {
            get => parent;
            set
            {
                if (parent == null)
                {
                    parent = value;
                    if (!parent._children.Contains(this))
                    {
                        parent._children.Add(this);
                    }
                }
                else
                {
                    // change the parent of this node:
                    parent._children.Remove(this);
                    parent = value;
                    if (!parent._children.Contains(this))
                    {
                        parent._children.Add(this);
                    }
                }
            }
        }

        /// <summary>
        ///     value property.
        /// </summary>
        public TV Value { get; set; }

        /// <summary>
        ///     the index within the parent tree collection.
        /// </summary>
        public int Index { get; set; }

        /// <summary>
        ///     query the children of this node.
        /// </summary>
        public IEnumerable<TreeNode<TV>> Children => from c in _children
            select c;

        /// <summary>
        ///     query this nodes siblings.
        /// </summary>
        public IEnumerable<TreeNode<TV>> Siblings
        {
            get
            {
                if (parent == null)
                {
                }
                else
                {
                    foreach (var sibling in parent.Children)
                    {
                        if (sibling != this)
                        {
                            yield return sibling;
                        }
                    }
                }
            }
        }

        /// <summary>
        ///     returns the parent of this node, it's parent and so on until the top of the tree is reached.
        /// </summary>
        public IEnumerable<TreeNode<TV>> PathToTop
        {
            get
            {
                var node = parent;
                while (node != null)
                {
                    yield return node;
                    node = node.parent;
                }
            }
        }

        /// <summary>
        ///     returns all the descendents of the current node in hierarchy order.
        /// </summary>
        public IEnumerable<TreeNode<TV>> Descendents
        {
            get
            {
                foreach (var node in _children)
                {
                    yield return node;
                    foreach (var descendent in node.Descendents)
                    {
                        yield return descendent;
                    }
                }
            }
        }

        /// <summary>
        ///     hierarchy path for this node.
        /// </summary>
        public string Path
        {
            get
            {
                if (parent == null)
                {
                    return this.Value.ToString();
                }

                return parent.Path + "\\" + this.Value;
            }
        }

        #endregion

        #region Collection Modification Methods

        /// <summary>
        ///     set the owning tree. the tree must already contain the node.
        /// </summary>
        /// <param name="owner"></param>
        public void SetOwner(Tree<TV> owner)
        {
            if (this.owner != null && this.owner != owner)
            {
                throw new ApplicationException("This node already belongs to a different tree!");
            }

            if (!owner.Contains(this))
            {
                throw new ApplicationException("Owner does not contain this node!");
            }

            // set the owner and index:
            this.owner = owner;
            this.Index = owner.IndexOf(this);

            // attach an event-handler to the tree's node-added event to keep the children up to date.
            this.owner.NodeAdded += _nodeAddedHandler;
        }

        /// <summary>
        ///     detach this node from it's owning tree.
        /// </summary>
        public void Detach()
        {
            this.RemoveFromTree(owner);
        }

        /// <summary>
        ///     remove this node, and all it's parents from the tree. the node cannot have children.
        /// </summary>
        /// <param name="owner"></param>
        public void RemoveFromTree(Tree<TV> owner)
        {
            if (_children.Count > 0)
            {
                throw new ApplicationException("Cannot remove a node with children!");
            }

            if (this.owner == null)
            {
                throw new ApplicationException("This node does not have an owner to remove");
            }

            this.Parent?.RemoveFromTree(owner);

            if (this.owner != null && this.owner == owner)
            {
                this.owner.Remove(this);
                this.owner = null;
            }
        }

        /// <summary>
        ///     add this node to the specified tree. the parent node must already be
        ///     in the collection.
        /// </summary>
        /// <param name="tree"></param>
        public void AddToTree(Tree<TV> tree)
        {
            if (owner != null && owner != tree)
            {
                throw new ApplicationException("This node already belongs to a different tree!");
            }

            if (!tree.Contains(this))
            {
                tree.Add(this);
            }
        }

        /// <summary>
        ///     update this nodes' internal list of children from the Tree's GetChildren method.
        /// </summary>
        public void UpdateChildren()
        {
            if (owner != null)
            {
                _children.Clear();
                foreach (var node in owner.GetChildren(this))
                {
                    _children.Add(node);
                }
            }
            else
            {
                throw new ApplicationException("Tree node must have an Owner!");
            }
        }

        #endregion
    }
}
